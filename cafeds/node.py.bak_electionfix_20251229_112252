import threading
import time
import socket
import uuid
from dataclasses import dataclass
from typing import Optional, Set, Tuple, Dict, Any

from .config import (
    DISCOVERY_TARGETS, DISCOVERY_INTERVAL, HEARTBEAT_INTERVAL, LEADER_TIMEOUT,
    LOG_PREFIX, DISCOVERY_PORT, NODE_UDP_BASE,
    ELECTION_ANSWER_TIMEOUT, COORDINATOR_TIMEOUT, CLUSTER_NODE_IDS
)
from .udp_bus import make_udp_socket, send_udp, recv_udp
from .proto import (
    encode, decode,
    who_is_leader, i_am_leader, leader_alive,
    election, answer, coordinator,
    new_order, order_msg, resend_request
)
from .tcp_server import TCPServer, ClientConn
from .tcp_client import TCPClient
from .net import primary_ip, local_ip_for_peer, discovery_targets


@dataclass
class LeaderInfo:
    leader_id: int
    leader_ip: str
    leader_tcp_port: int
    epoch: int
    last_seq: int
    last_seen_ts: float


class Node:
    def __init__(self, node_id: int, role: str, tcp_port: int, ui: str):
        self.node_id = node_id
        self.role = role
        self.tcp_port = tcp_port
        self.ui = ui

        # UDP sockets:
        # - node UDP (unique) always
        self.node_udp_port = NODE_UDP_BASE + node_id
        self.udp_node = make_udp_socket(self.node_udp_port)

        # - discovery UDP (only when leader)
        self.udp_disc: Optional[socket.socket] = None
        if role == "leader":
            self.udp_disc = make_udp_socket(DISCOVERY_PORT)

        self.stop_event = threading.Event()

        # Sequencer/log state (EVERYONE keeps history)
        self.epoch = 1
        self.last_seq = 0
        self.history: Dict[int, Dict[str, Any]] = {}
        self.history_lock = threading.Lock()

        # Follower leader info
        self.leader: Optional[LeaderInfo] = None

        # TCP
        self.tcp_server: Optional[TCPServer] = None
        self.tcp_client: Optional[TCPClient] = None
        self.tcp_connected = False
        self.tcp_lock = threading.Lock()

        # Total-order delivery (follower)
        self.expected_seq = 1
        self.buffer: Dict[int, Dict[str, Any]] = {}
        self.delivered_seqs = set()      # dedup seqs delivered
        self.delivery_lock = threading.Lock()  # protect expected_seq/buffer
        self.last_resend_ts = 0.0        # resend rate-limit
        self.in_election_since = 0.0     # prevent double-election spam

        # election state
        self.in_election = False
        self.answer_event = threading.Event()
        self.coordinator_event = threading.Event()
        self.coordinator_msg: Optional[Dict[str, Any]] = None
        self.election_lock = threading.Lock()

        # Threads
        self.threads: Set[threading.Thread] = set()

    def log(self, msg: str) -> None:
        print(f"{LOG_PREFIX} [id={self.node_id} role={self.role} udp_node={self.node_udp_port}] {msg}", flush=True)

    # ---------------- RUN ----------------

    def run(self) -> None:
        # UDP listeners
        t1 = threading.Thread(target=self._udp_node_listener, daemon=True)
        t1.start()
        self.threads.add(t1)

        if self.udp_disc is not None:
            t2 = threading.Thread(target=self._udp_disc_listener, daemon=True)
            t2.start()
            self.threads.add(t2)

        # TCP init
        if self.role == "leader":
            self._start_tcp_leader()
            self._start_leader_heartbeat_thread()
        else:
            self._start_tcp_follower()
            if self.ui == "waiter":
                tw = threading.Thread(target=self._stdin_order_loop, daemon=True)
                tw.start()
                self.threads.add(tw)

        # main follower discovery thread
        tf = threading.Thread(target=self._follower_discovery_loop, daemon=True)
        tf.start()
        self.threads.add(tf)

        self.log("Node is running.")

        # keep process alive
        while not self.stop_event.is_set():
            time.sleep(0.5)

    # ---------------- UDP HELPERS ----------------

    def _port_of(self, node_id: int) -> int:
        return NODE_UDP_BASE + node_id

    def _send_to_node(self, target_id: int, msg: Dict[str, Any]) -> None:
        payload = encode(msg)
        port = self._port_of(target_id)
        for ip in discovery_targets():
            try:
                send_udp(self.udp_node, payload, ip, port)
            except Exception:
                pass


    def _safe_start_election(self, reason: str = "") -> None:
        # single-flight election starter (prevents epoch=2 then epoch=3 spam)
        import time as _time
        if getattr(self, "role", "") == "leader":
            return
        now = _time.time()
        with self.election_lock:
            since = getattr(self, "in_election_since", 0.0)
            if getattr(self, "in_election", False) and (now - since) < 2.0:
                return
            self.in_election = True
            self.in_election_since = now

        if reason:
            try: self.log(f"{reason} -> starting election")
            except Exception: pass

        import threading as _threading
        th = _threading.Thread(target=self._bully_election, daemon=True)
        th.start()

    def _process_order(self, msg) -> None:
        # seq-based total-order delivery: dedup + in-order buffer + resend on gaps
        if not msg:
            return
        try:
            seq = int(msg.get("seq", -1))
        except Exception:
            return
        if seq <= 0:
            return

        # keep history for leader handover
        try:
            with self.history_lock:
                self.history[seq] = msg
                self.last_seq = max(getattr(self, "last_seq", 0), seq)
        except Exception:
            pass

        with self.delivery_lock:
            # dedup
            if seq in self.delivered_seqs or seq < self.expected_seq:
                self.delivered_seqs.add(seq)
                return

            # gap => buffer + ask resend
            if seq > self.expected_seq:
                self.buffer[seq] = msg
                import time as _time
                now = _time.time()
                if getattr(self, "tcp_client", None) and getattr(self, "tcp_connected", False) and (now - self.last_resend_ts) >= 0.5:
                    self.last_resend_ts = now
                    try:
                        req = resend_request(self.expected_seq)  # if exists
                    except Exception:
                        req = {"type":"RESEND_REQUEST","sender_id":getattr(self,"node_id",0),"from_seq":self.expected_seq}
                    try:
                        self.tcp_client.send(req)
                        self.log(f"RESEND_REQUEST sent from_seq={self.expected_seq}")
                    except Exception:
                        pass
                return

            # seq == expected => deliver and flush
            self._deliver(msg)
            self.delivered_seqs.add(seq)
            self.expected_seq += 1

            while self.expected_seq in self.buffer:
                m2 = self.buffer.pop(self.expected_seq)
                s2 = self.expected_seq
                if s2 in self.delivered_seqs:
                    self.expected_seq += 1
                    continue
                self._deliver(m2)
                self.delivered_seqs.add(s2)
                self.expected_seq += 1

    # ---------------- UDP LISTENERS ----------------

    def _udp_node_listener(self) -> None:
        self.log("UDP node listener started.")
        while not self.stop_event.is_set():
            try:
                data, (src_ip, src_port) = recv_udp(self.udp_node)
                msg = decode(data)
                mtype = msg.get("type")

                # ---- FIX: Leader discovery / heartbeat ----
                if mtype == "I_AM_LEADER" and self.role == "follower":
                    new_id = int(msg.get("leader_id", -1))
                    new_ip = str(msg.get("leader_ip", "127.0.0.1"))
                    new_tcp = int(msg.get("leader_tcp_port", 0))
                    new_epoch = int(msg.get("epoch", 1))
                    new_last = int(msg.get("last_seq", 0))
                    self.leader = LeaderInfo(
                        leader_id=new_id,
                        leader_ip=new_ip,
                        leader_tcp_port=new_tcp,
                        epoch=new_epoch,
                        last_seq=new_last,
                        last_seen_ts=time.time(),
                    )
                    self.epoch = max(self.epoch, new_epoch)
                    self.log(f"Leader discovered: {new_id} @ {new_ip}:{new_tcp} (epoch={new_epoch})")

                elif mtype == "LEADER_ALIVE" and self.role == "follower":
                    lid = int(msg.get("leader_id", -1))
                    e = int(msg.get("epoch", 1))
                    ls = int(msg.get("last_seq", 0))
                    if self.leader is None or self.leader.leader_id == lid:
                        if self.leader is None:
                            self.leader = LeaderInfo(
                                leader_id=lid,
                                leader_ip=local_ip_for_peer(src_ip),
                                leader_tcp_port=0,
                                epoch=e,
                                last_seq=ls,
                                last_seen_ts=time.time(),
                            )
                        else:
                            self.leader.last_seen_ts = time.time()
                            self.leader.epoch = max(self.leader.epoch, e)
                            self.leader.last_seq = max(self.leader.last_seq, ls)
                        self.epoch = max(self.epoch, e)


                if mtype == "ELECTION":
                    cand = int(msg.get("candidate_id", -1))
                    e = int(msg.get("epoch", 1))
                    if self.node_id > cand:
                        # Reply ANSWER to candidate's node port
                        try:
                            send_udp(self.udp_node, encode(answer(self.node_id, max(self.epoch, e))), src_ip, src_port)
                        except Exception:
                            pass
                        # Bully: higher node should also start election
                        self._maybe_start_election_async()

                elif mtype == "ANSWER":
                    self.answer_event.set()

                elif mtype == "COORDINATOR":
                    self.coordinator_msg = msg
                    self.coordinator_event.set()
                    # If I'm leader but see higher epoch coordinator, step down
                    lead_id = int(msg.get("leader_id", -1))
                    e = int(msg.get("epoch", 1))
                    if self.role == "leader" and lead_id != self.node_id and e >= self.epoch:
                        self.log(f"Stepping down: coordinator {lead_id} epoch={e}")
                        self._demote_to_follower(LeaderInfo(
                            leader_id=lead_id,
                            leader_ip=str(msg.get('leader_ip','127.0.0.1')),
                            leader_tcp_port=int(msg.get('leader_tcp_port',0)),
                            epoch=e,
                            last_seq=int(msg.get('last_seq',0)),
                            last_seen_ts=time.time()
                        ))

            except socket.timeout:
                continue
            except OSError:
                if self.stop_event.is_set():
                    break
            except Exception as e:
                self.log(f"UDP node listener error: {e}")

    def _udp_disc_listener(self) -> None:
        assert self.udp_disc is not None
        self.log("UDP discovery listener started.")
        while not self.stop_event.is_set():
            try:
                data, (src_ip, src_port) = recv_udp(self.udp_disc)
                msg = decode(data)
                if msg.get("type") == "WHO_IS_LEADER" and self.role == "leader":
                    reply = i_am_leader(
                        leader_id=self.node_id,
                        leader_ip=local_ip_for_peer(src_ip),
                        leader_tcp_port=self.tcp_port,
                        epoch=self.epoch,
                        last_seq=self.last_seq,
                    )
                    send_udp(self.udp_disc, encode(reply), src_ip, src_port)
            except socket.timeout:
                continue
            except OSError:
                if self.stop_event.is_set():
                    break
            except Exception:
                pass

    # ---------------- FOLLOWER DISCOVERY + TIMEOUT ----------------

    def _follower_discovery_loop(self) -> None:
        while not self.stop_event.is_set():
            if self.role != "follower":
                time.sleep(0.5)
                continue

            now = time.time()

            # TCP connected => refresh leader last_seen_ts (prevents election spam)
            with self.tcp_lock:
                tcp_ok = self.tcp_connected
            if self.leader and tcp_ok:
                self.leader.last_seen_ts = now


            # leader timeout?
            if self.leader and (now - self.leader.last_seen_ts) > LEADER_TIMEOUT:
                with self.election_lock:
                    already = self.in_election
                if not already:
                    # already electing? ignore duplicate trigger
                    with self.election_lock:
                        if getattr(self, 'in_election', False):
                            continue
                    self.log("Leader timeout -> starting election")
                    self.leader = None
                    self._close_tcp_client()
                    self._safe_start_election('')

                # already electing? ignore duplicate trigger
                with self.election_lock:
                    if getattr(self, 'in_election', False):
                        continue
                self.log("Leader timeout -> starting election")
                self.leader = None
                self._close_tcp_client()
                self._safe_start_election('')

            # If leader unknown: ask via discovery port
            if self.leader is None and not self.in_election:
                q = who_is_leader(self.node_id, self.tcp_port)
                payload = encode(q)
                for ip in DISCOVERY_TARGETS:
                    try:
                        send_udp(self.udp_node, payload, ip, DISCOVERY_PORT)
                    except Exception:
                        pass

            # If leader known but TCP not connected: connect
            if self.leader is not None:
                self._ensure_tcp_connected()

            time.sleep(DISCOVERY_INTERVAL)

    # ---------------- TCP LEADER ----------------

    def _start_tcp_leader(self) -> None:
        def on_msg(conn: ClientConn, msg: Dict[str, Any]) -> None:
            mtype = msg.get("type")

            if mtype == "NEW_ORDER":
                with self.history_lock:
                    self.last_seq = max(self.last_seq, max(self.history.keys(), default=0))
                    self.last_seq += 1
                    seq = self.last_seq
                    om = order_msg(
                        leader_id=self.node_id,
                        epoch=self.epoch,
                        seq=seq,
                        order_uuid=str(msg.get("order_uuid")),
                        payload=dict(msg.get("payload", {})),
                    )
                    self.history[seq] = om

                self.log(f"NEW_ORDER -> seq={seq} (broadcast ORDER)")
                assert self.tcp_server is not None
                self.tcp_server.broadcast(om)

            elif mtype == "RESEND_REQUEST":
                from_seq = int(msg.get("from_seq", 1))
                with self.history_lock:
                    for s in range(from_seq, max(self.history.keys(), default=0) + 1):
                        if s in self.history:
                            conn.send(self.history[s])

        self.tcp_server = TCPServer("0.0.0.0", self.tcp_port, on_msg=on_msg, on_log=self.log)
        self.tcp_server.start()

    def _start_leader_heartbeat_thread(self) -> None:
        t = threading.Thread(target=self._leader_heartbeat_loop, daemon=True)
        t.start()
        self.threads.add(t)

    def _leader_heartbeat_loop(self) -> None:
        while not self.stop_event.is_set():
            if self.role != "leader":
                time.sleep(0.5)
                continue

            # heartbeat to all cluster nodes (robust after election)
            with self.history_lock:
                self.last_seq = max(self.last_seq, max(self.history.keys(), default=0))

            hb = leader_alive(self.node_id, self.epoch, self.last_seq)
            for nid in CLUSTER_NODE_IDS:
                if nid == self.node_id:
                    continue
                try:
                    self._send_to_node(nid, hb)
                except Exception:
                    pass

            time.sleep(HEARTBEAT_INTERVAL)

    # ---------------- TCP FOLLOWER ----------------

    def _start_tcp_follower(self) -> None:
        def on_msg(msg: Dict[str, Any]) -> None:
            if msg.get("type") == "ORDER":
                self._process_order(locals().get('msg') or locals().get('m') or locals().get('message'))
                return
                self._handle_order(msg)
            elif msg.get("type") == "I_AM_LEADER":
                # not used on TCP
                pass

        def on_log(s: str) -> None:
            # if disconnected, mark not connected
            if "disconnected" in s.lower() or "stopped" in s.lower():
                with self.tcp_lock:
                    self.tcp_connected = False
            self.log(s)

        self.tcp_client = TCPClient(on_msg=on_msg, on_log=on_log)

    def _ensure_tcp_connected(self) -> None:
        if not self.leader or not self.tcp_client:
            return
        with self.tcp_lock:
            if self.tcp_connected:
                return

        host = self.leader.leader_ip
        port = self.leader.leader_tcp_port
        if port == 0:
            return

        ok = self.tcp_client.connect(host, port)
        with self.tcp_lock:
            self.tcp_connected = ok

        if ok:
            # catch-up
            self.tcp_client.send(resend_request(self.expected_seq))

    def _close_tcp_client(self) -> None:
        with self.tcp_lock:
            self.tcp_connected = False
        if self.tcp_client:
            self.tcp_client.close()

    # ---------------- DELIVERY ----------------

    def _handle_order(self, msg: Dict[str, Any]) -> None:
        seq = int(msg.get("seq", -1))
        if seq <= 0:
            return

        # store in local history (so any node can become leader)
        with self.history_lock:
            self.history[seq] = msg
            self.last_seq = max(self.last_seq, seq)

        if seq < self.expected_seq:
            return

        if seq > self.expected_seq:
            self.buffer[seq] = msg
            if self.tcp_client:
                self.tcp_client.send(resend_request(self.expected_seq))
            return

        self._deliver(msg)
        self.expected_seq += 1

        while self.expected_seq in self.buffer:
            m = self.buffer.pop(self.expected_seq)
            self._deliver(m)
            self.expected_seq += 1

    def _deliver(self, msg: Dict[str, Any]) -> None:
        payload = msg.get("payload", {})
        text = payload.get("text", str(payload))
        self.log(f"DELIVER seq={msg.get('seq')} | {text}")

    # ---------------- WAITER INPUT ----------------

    def _stdin_order_loop(self) -> None:
        self.log("WAITER: type order and press Enter")
        while not self.stop_event.is_set():
            try:
                line = input()
            except Exception:
                break
            line = (line or "").strip()
            if not line:
                continue
            self.submit_order({"text": line})

    def submit_order(self, payload: Dict[str, Any]) -> None:
        # If I'm leader, accept local orders (demo-friendly) and broadcast directly
        if self.role == "leader":
            oid = str(uuid.uuid4())
            with self.history_lock:
                self.last_seq = max(self.last_seq, max(self.history.keys(), default=0))
                self.last_seq += 1
                seq = self.last_seq
                om = order_msg(self.node_id, self.epoch, seq, oid, payload)
                self.history[seq] = om
            self.log(f"LOCAL_ORDER -> seq={seq} (broadcast ORDER)")
            if self.tcp_server:
                self.tcp_server.broadcast(om)
            # also show locally
            self._deliver(om)
            return

        # follower path: send NEW_ORDER to leader
        if not self.tcp_client:
            self.log("Cannot submit order: tcp_client missing")
            return
        with self.tcp_lock:
            if not self.tcp_connected:
                self.log("Cannot submit order: not connected to leader yet")
                return

        oid = str(uuid.uuid4())
        self.tcp_client.send(new_order(self.node_id, oid, payload))
        self.log(f"Sent NEW_ORDER uuid={oid}")

    # ---------------- BULLY ELECTION ----------------

    def _maybe_start_election_async(self) -> None:
        # Start election in background if not already
        with self.election_lock:
            if self.in_election or self.role != "follower":
                return
            self.in_election = True
        t = threading.Thread(target=self._bully_election, daemon=True)
        t.start()
        self.threads.add(t)

    def _bully_election(self) -> None:
        # SINGLE_FLIGHT_ELECTION_GUARD
        import time as _time
        now = _time.time()
        with self.election_lock:
            since = getattr(self, 'in_election_since', 0.0)
            if getattr(self, 'in_election', False) and (now - since) < 3.0:
                return
            self.in_election = True
            self.in_election_since = now

        with self.election_lock:
            if self.in_election:
                # already in election
                pass
            else:
                self.in_election = True

        self.answer_event.clear()
        self.coordinator_event.clear()
        self.coordinator_msg = None

        # propose new epoch
        proposed_epoch = self.epoch + 1

        higher = [nid for nid in CLUSTER_NODE_IDS if nid > self.node_id]
        self.log(f"Election started. higher={higher}")

        # send ELECTION to higher nodes
        for nid in higher:
            try:
                self._send_to_node(nid, election(self.node_id, proposed_epoch))
            except Exception:
                pass

        # wait for ANSWER
        got_answer = self.answer_event.wait(ELECTION_ANSWER_TIMEOUT)

        if not got_answer:
            # I am the coordinator
            self.log("No ANSWER -> I become LEADER")
            self._promote_to_leader(new_epoch=proposed_epoch)
            with self.election_lock:
                self.in_election = False
            return

        # someone higher is alive -> wait coordinator
        self.log("Got ANSWER -> waiting for COORDINATOR")
        got_coord = self.coordinator_event.wait(COORDINATOR_TIMEOUT)

        if not got_coord or not self.coordinator_msg:
            self.log("Coordinator timeout -> retry election")
            with self.election_lock:
                self.in_election = False
            return

        # accept coordinator
        msg = self.coordinator_msg
        lead = LeaderInfo(
            leader_id=int(msg["leader_id"]),
            leader_ip=str(msg.get("leader_ip", "127.0.0.1")),
            leader_tcp_port=int(msg.get("leader_tcp_port", 0)),
            epoch=int(msg.get("epoch", proposed_epoch)),
            last_seq=int(msg.get("last_seq", 0)),
            last_seen_ts=time.time()
        )
        self.epoch = max(self.epoch, lead.epoch)
        self.leader = lead
        self.log(f"COORDINATOR is {lead.leader_id} @ {lead.leader_ip}:{lead.leader_tcp_port} epoch={lead.epoch}")
        # reset election on coordinator
        with self.election_lock:
            self.in_election = False
        self.in_election_since = 0.0

        with self.election_lock:
            self.in_election = False

        self._ensure_tcp_connected()

    def _promote_to_leader(self, new_epoch: int) -> None:
        # close follower tcp
        self._close_tcp_client()

        # stop being follower
        self.role = "leader"
        self.epoch = max(self.epoch + 1, new_epoch)

        # ensure discovery socket exists (bind 37020)
        if self.udp_disc is None:
            try:
                self.udp_disc = make_udp_socket(DISCOVERY_PORT)
                t = threading.Thread(target=self._udp_disc_listener, daemon=True)
                t.start()
                self.threads.add(t)
            except Exception as e:
                self.log(f"Failed to bind discovery port: {e}")

        # start TCP server if not running
        if self.tcp_server is None:
            self._start_tcp_leader()

        # update last_seq from local history
        with self.history_lock:
            self.last_seq = max(self.last_seq, max(self.history.keys(), default=0))

        # announce coordinator to cluster
        msg = coordinator(self.node_id, primary_ip(), self.tcp_port, self.epoch, self.last_seq)
        for nid in CLUSTER_NODE_IDS:
            if nid == self.node_id:
                continue
            try:
                self._send_to_node(nid, msg)
            except Exception:
                pass

        self.log(f"Announced COORDINATOR epoch={self.epoch} last_seq={self.last_seq}")

        # reset election state after becoming leader

        with self.election_lock:

            self.in_election = False

        self.in_election_since = 0.0
    def _demote_to_follower(self, new_leader: LeaderInfo) -> None:
        if self.role != "leader":
            self.leader = new_leader
            return

        # stop server
        if self.tcp_server:
            self.tcp_server.stop()
            self.tcp_server = None

        self.role = "follower"
        self.leader = new_leader
        self._start_tcp_follower()
        self.log("Demoted to follower.")

    # ---------------- STOP ----------------

    def stop(self) -> None:
        self.stop_event.set()
        try:
            self.udp_node.close()
        except Exception:
            pass
        try:
            if self.udp_disc:
                self.udp_disc.close()
        except Exception:
            pass
        if self.tcp_client:
            self.tcp_client.close()
        if self.tcp_server:
            self.tcp_server.stop()
