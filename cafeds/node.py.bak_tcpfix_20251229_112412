import threading
import time
import socket
import uuid
from dataclasses import dataclass
from typing import Optional, Set, Tuple, Dict, Any

from .config import (
    DISCOVERY_TARGETS, DISCOVERY_INTERVAL, HEARTBEAT_INTERVAL, LEADER_TIMEOUT,
    LOG_PREFIX, DISCOVERY_PORT, NODE_UDP_BASE,
    ELECTION_ANSWER_TIMEOUT, COORDINATOR_TIMEOUT, CLUSTER_NODE_IDS
)
from .udp_bus import make_udp_socket, send_udp, recv_udp
from .proto import (
    encode, decode,
    who_is_leader, i_am_leader, leader_alive,
    election, answer, coordinator,
    new_order, order_msg, resend_request
)
from .tcp_server import TCPServer, ClientConn
from .tcp_client import TCPClient
from .net import primary_ip, local_ip_for_peer, discovery_targets


@dataclass
class LeaderInfo:
    leader_id: int
    leader_ip: str
    leader_tcp_port: int
    epoch: int
    last_seq: int
    last_seen_ts: float


class Node:
    def __init__(self, node_id: int, role: str, tcp_port: int, ui: str):
        self.node_id = node_id
        self.role = role
        self.tcp_port = tcp_port
        self.ui = ui

        # UDP sockets:
        # - node UDP (unique) always
        self.node_udp_port = NODE_UDP_BASE + node_id
        self.udp_node = make_udp_socket(self.node_udp_port)

        # - discovery UDP (only when leader)
        self.udp_disc: Optional[socket.socket] = None
        if role == "leader":
            self.udp_disc = make_udp_socket(DISCOVERY_PORT)

        self.stop_event = threading.Event()

        # Sequencer/log state (EVERYONE keeps history)
        self.epoch = 1
        self.last_seq = 0
        self.history: Dict[int, Dict[str, Any]] = {}
        self.history_lock = threading.Lock()

        # Follower leader info
        self.leader: Optional[LeaderInfo] = None

        # TCP
        self.tcp_server: Optional[TCPServer] = None
        self.tcp_client: Optional[TCPClient] = None
        self.tcp_connected = False
        self.tcp_lock = threading.Lock()

        # Total-order delivery (follower)
        self.expected_seq = 1
        self.buffer: Dict[int, Dict[str, Any]] = {}
        self.delivered_seqs = set()      # dedup seqs delivered
        self.delivery_lock = threading.Lock()  # protect expected_seq/buffer
        self.last_resend_ts = 0.0        # resend rate-limit
        self.in_election_since = 0.0     # prevent double-election spam
        self._election_thread = None

        # election state
        self.in_election = False
        self.answer_event = threading.Event()
        self.coordinator_event = threading.Event()
        self.coordinator_msg: Optional[Dict[str, Any]] = None
        self.election_lock = threading.Lock()

        # Threads
        self.threads: Set[threading.Thread] = set()

    def log(self, msg: str) -> None:
        print(f"{LOG_PREFIX} [id={self.node_id} role={self.role} udp_node={self.node_udp_port}] {msg}", flush=True)

    # ---------------- RUN ----------------


    def _start_election_thread(self, reason: str = "") -> None:
        # Start Bully election asynchronously (prevents blocking + double elections)
        if getattr(self, "role", "") == "leader":
            return
        import time
        with self.election_lock:
            # if an election thread already running, do nothing
            th = getattr(self, "_election_thread", None)
            if th is not None and th.is_alive():
                return
            if getattr(self, "in_election", False):
                return
            self.in_election = True
            self.in_election_since = time.time()
            self._election_thread = threading.Thread(target=self._bully_election, daemon=True)

        if reason:
            try:
                self.log(f"{reason} -> starting election")
            except Exception:
                pass
        self._election_thread.start()

    def run(self) -> None:
        # UDP listeners
        t1 = threading.Thread(target=self._udp_node_listener, daemon=True)
        t1.start()
        self.threads.add(t1)

        if self.udp_disc is not None:
            t2 = threading.Thread(target=self._udp_disc_listener, daemon=True)
            t2.start()
            self.threads.add(t2)

        # TCP init
        if self.role == "leader":
            self._start_tcp_leader()
            self._start_leader_heartbeat_thread()
        else:
            self._start_tcp_follower()
            if self.ui == "waiter":
                tw = threading.Thread(target=self._stdin_order_loop, daemon=True)
                tw.start()
                self.threads.add(tw)

        # main follower discovery thread
        tf = threading.Thread(target=self._follower_discovery_loop, daemon=True)
        tf.start()
        self.threads.add(tf)

        self.log("Node is running.")

        # keep process alive
        while not self.stop_event.is_set():
            time.sleep(0.5)

    # ---------------- UDP HELPERS ----------------

    def _port_of(self, node_id: int) -> int:
        return NODE_UDP_BASE + node_id

    def _send_to_node(self, target_id: int, msg: Dict[str, Any]) -> None:
        payload = encode(msg)
        port = self._port_of(target_id)
        for ip in discovery_targets():
            try:
                send_udp(self.udp_node, payload, ip, port)
            except Exception:
                pass


    def _safe_start_election(self, reason: str = "") -> None:
        # single-flight election starter (prevents epoch=2 then epoch=3 spam)
        import time as _time
        if getattr(self, "role", "") == "leader":
            return
        now = _time.time()
        with self.election_lock:
            since = getattr(self, "in_election_since", 0.0)
            if getattr(self, "in_election", False) and (now - since) < 2.0:
                return
            self.in_election = True
            self.in_election_since = now

        if reason:
            try: self.log(f"{reason} -> starting election")
            except Exception: pass

        import threading as _threading
        th = _threading.Thread(target=self._bully_election, daemon=True)
        th.start()

    def _process_order(self, msg) -> None:
        # seq-based total-order delivery: dedup + in-order buffer + resend on gaps
        if not msg:
            return
        try:
            seq = int(msg.get("seq", -1))
        except Exception:
            return
        if seq <= 0:
            return

        # keep history for leader handover
        try:
            with self.history_lock:
                self.history[seq] = msg
                self.last_seq = max(getattr(self, "last_seq", 0), seq)
        except Exception:
            pass

        with self.delivery_lock:
            # dedup
            if seq in self.delivered_seqs or seq < self.expected_seq:
                self.delivered_seqs.add(seq)
                return

            # gap => buffer + ask resend
            if seq > self.expected_seq:
                self.buffer[seq] = msg
                import time as _time
                now = _time.time()
                if getattr(self, "tcp_client", None) and getattr(self, "tcp_connected", False) and (now - self.last_resend_ts) >= 0.5:
                    self.last_resend_ts = now
                    try:
                        req = resend_request(self.expected_seq)  # if exists
                    except Exception:
                        req = {"type":"RESEND_REQUEST","sender_id":getattr(self,"node_id",0),"from_seq":self.expected_seq}
                    try:
                        self.tcp_client.send(req)
                        self.log(f"RESEND_REQUEST sent from_seq={self.expected_seq}")
                    except Exception:
                        pass
                return

            # seq == expected => deliver and flush
            self._deliver(msg)
            self.delivered_seqs.add(seq)
            self.expected_seq += 1

            while self.expected_seq in self.buffer:
                m2 = self.buffer.pop(self.expected_seq)
                s2 = self.expected_seq
                if s2 in self.delivered_seqs:
                    self.expected_seq += 1
                    continue
                self._deliver(m2)
                self.delivered_seqs.add(s2)
                self.expected_seq += 1

    # ---------------- UDP LISTENERS ----------------

    def _udp_node_listener(self) -> None:
        self.log("UDP node listener started.")
        while not self.stop_event.is_set():
            try:
                data, (src_ip, src_port) = recv_udp(self.udp_node)
                msg = decode(data)
                mtype = msg.get("type")

                # ---- FIX: Leader discovery / heartbeat ----
                if mtype == "I_AM_LEADER" and self.role == "follower":
                    new_id = int(msg.get("leader_id", -1))
                    new_ip = str(msg.get("leader_ip", "127.0.0.1"))
                    new_tcp = int(msg.get("leader_tcp_port", 0))
                    new_epoch = int(msg.get("epoch", 1))
                    new_last = int(msg.get("last_seq", 0))
                    self.leader = LeaderInfo(
                        leader_id=new_id,
                        leader_ip=new_ip,
                        leader_tcp_port=new_tcp,
                        epoch=new_epoch,
                        last_seq=new_last,
                        last_seen_ts=time.time(),
                    )
                    self.epoch = max(self.epoch, new_epoch)
                    self.log(f"Leader discovered: {new_id} @ {new_ip}:{new_tcp} (epoch={new_epoch})")

                elif mtype == "LEADER_ALIVE" and self.role == "follower":
                    lid = int(msg.get("leader_id", -1))
                    e = int(msg.get("epoch", 1))
                    ls = int(msg.get("last_seq", 0))
                    if self.leader is None or self.leader.leader_id == lid:
                        if self.leader is None:
                            self.leader = LeaderInfo(
                                leader_id=lid,
                                leader_ip=local_ip_for_peer(src_ip),
                                leader_tcp_port=0,
                                epoch=e,
                                last_seq=ls,
                                last_seen_ts=time.time(),
                            )
                        else:
                            self.leader.last_seen_ts = time.time()
                            self.leader.epoch = max(self.leader.epoch, e)
                            self.leader.last_seq = max(self.leader.last_seq, ls)
                        self.epoch = max(self.epoch, e)


                if mtype == "ELECTION":
                    cand = int(msg.get("candidate_id", -1))
                    e = int(msg.get("epoch", 1))
                    if self.node_id > cand:
                        # Reply ANSWER to candidate's node port
                        try:
                            send_udp(self.udp_node, encode(answer(self.node_id, max(self.epoch, e))), src_ip, src_port)
                        except Exception:
                            pass
                        # Bully: higher node should also start election
                        self._maybe_start_election_async()

                elif mtype == "ANSWER":
                    self.answer_event.set()

                elif mtype == "COORDINATOR":
                    self.coordinator_msg = msg
                    self.coordinator_event.set()
                    # If I'm leader but see higher epoch coordinator, step down
                    lead_id = int(msg.get("leader_id", -1))
                    e = int(msg.get("epoch", 1))
                    if self.role == "leader" and lead_id != self.node_id and e >= self.epoch:
                        self.log(f"Stepping down: coordinator {lead_id} epoch={e}")
                        self._demote_to_follower(LeaderInfo(
                            leader_id=lead_id,
                            leader_ip=str(msg.get('leader_ip','127.0.0.1')),
                            leader_tcp_port=int(msg.get('leader_tcp_port',0)),
                            epoch=e,
                            last_seq=int(msg.get('last_seq',0)),
                            last_seen_ts=time.time()
                        ))

            except socket.timeout:
                continue
            except OSError:
                if self.stop_event.is_set():
                    break
            except Exception as e:
                self.log(f"UDP node listener error: {e}")

    def _udp_disc_listener(self) -> None:
        assert self.udp_disc is not None
        self.log("UDP discovery listener started.")
        while not self.stop_event.is_set():
            try:
                data, (src_ip, src_port) = recv_udp(self.udp_disc)
                msg = decode(data)
                if msg.get("type") == "WHO_IS_LEADER" and self.role == "leader":
                    reply = i_am_leader(
                        leader_id=self.node_id,
                        leader_ip=local_ip_for_peer(src_ip),
                        leader_tcp_port=self.tcp_port,
                        epoch=self.epoch,
                        last_seq=self.last_seq,
                    )
                    send_udp(self.udp_disc, encode(reply), src_ip, src_port)
            except socket.timeout:
                continue
            except OSError:
                if self.stop_event.is_set():
                    break
            except Exception:
                pass

    # ---------------- FOLLOWER DISCOVERY + TIMEOUT ----------------

    def _follower_discovery_loop(self) -> None:
        while not self.stop_event.is_set():
            if self.role != "follower":
                time.sleep(0.5)
                continue

            now = time.time()

            # TCP connected => refresh leader last_seen_ts (prevents election spam)
            with self.tcp_lock:
                tcp_ok = self.tcp_connected
            if self.leader and tcp_ok:
                self.leader.last_seen_ts = now


            # leader timeout?
            if self.leader and (now - self.leader.last_seen_ts) > LEADER_TIMEOUT:
                # already electing? don't spam
                if getattr(self, 'in_election', False):
                    time.sleep(0.1)
                else:
                    self.leader = None
                    self._close_tcp_client()
                    self._start_election_thread('Leader timeout')

